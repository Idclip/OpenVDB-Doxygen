<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB AX: AST.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB AX
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_abffb41b2fb02e852dda76d88b79b6c6.html">ast</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AST.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides the definition for every abstract and concrete derived class which represent a particular abstract syntax tree (AST) node type. Also provides access to the parser for generating a fully constructed AST from a given string.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="Tokens_8h_source.html">Tokens.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Literals_8h_source.html">Literals.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="version_8h_source.html">openvdb_ax/version.h</a>&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for AST.h:</div>
<div class="dyncontent">
<div class="center"><img src="AST_8h__incl.png" border="0" usemap="#AST_8h" alt=""/></div>
<map name="AST_8h" id="AST_8h">
<area shape="rect" id="node2" href="Tokens_8h.html" title="Various function and operator tokens used throughout the AST and code generation. ..." alt="" coords="343,80,419,107"/>
<area shape="rect" id="node11" href="Literals_8h.html" title="Literals.h" alt="" coords="743,80,817,107"/>
<area shape="rect" id="node4" href="version_8h.html" title="Library and file format version numbers. " alt="" coords="467,155,616,181"/>
<area shape="rect" id="node6" href="Exceptions_8h.html" title="openvdb_ax/Exceptions.h" alt="" coords="21,155,192,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="AST_8h__dep__incl.png" border="0" usemap="#AST_8hdep" alt=""/></div>
<map name="AST_8hdep" id="AST_8hdep">
<area shape="rect" id="node2" href="Scanners_8h.html" title="Scanners.h" alt="" coords="461,155,549,181"/>
<area shape="rect" id="node11" href="Visitor_8h.html" title="Contains the AX AST Node Visitor, providing default and customizable traversal and visitation methods..." alt="" coords="537,80,607,107"/>
<area shape="rect" id="node12" href="ComputeGenerator_8h.html" title="The core visitor framework for code generation. " alt="" coords="538,229,680,256"/>
<area shape="rect" id="node3" href="AttributeRegistry_8h.html" title="These classes contain lists of expected attributes and volumes which are populated by compiler during..." alt="" coords="359,229,489,256"/>
<area shape="rect" id="node13" href="Compiler_8h.html" title="Compiler.h" alt="" coords="696,155,781,181"/>
<area shape="rect" id="node14" href="util_8h.html" title="util.h" alt="" coords="733,80,784,107"/>
<area shape="rect" id="node4" href="PointComputeGenerator_8h.html" title="The visitor framework and function definition for point data grid code generation. " alt="" coords="541,304,715,331"/>
<area shape="rect" id="node5" href="VolumeComputeGenerator_8h.html" title="The visitor framework and function definition for volume grid code generation. " alt="" coords="331,304,517,331"/>
<area shape="rect" id="node6" href="PointExecutable_8h.html" title="Contains PointExecutable class. " alt="" coords="179,304,307,331"/>
<area shape="rect" id="node9" href="VolumeExecutable_8h.html" title="Contains VolumeExecutable class. " alt="" coords="11,304,153,331"/>
<area shape="rect" id="node7" href="pyPointExecutable_8h.html" title="Python wrapper for PointExecutable. " alt="" coords="185,379,327,405"/>
<area shape="rect" id="node8" href="pyCompiler_8h.html" title="Python wrapper for compiler class. " alt="" coords="207,453,305,480"/>
<area shape="rect" id="node10" href="pyVolumeExecutable_8h.html" title="Python wrapper for VolumeExecutable. " alt="" coords="5,379,160,405"/>
</map>
</div>
</div>
<p><a href="AST_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base abstract node which determines the interface and required methods for all derived concrete nodes which comprise a valid AST.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Statement.html">Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract (pure-virtual) AST nodes.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions are comprised of full or potentially partial parts of a full statement that may not necessary make up an entire valid statement on their own. For example, while a Binary Operator such as "3 + 5;"" is a valid statement on its own, the full statement
       "3 + 5 + 6;" must be broken down into two expressions which together form the statement as well as determining precedence.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types, they also consolidate data for the derived types.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ValueBase.html">ValueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ValueBases are a base class for anything that holds a value (literal). Derived classes store the actual typed values.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ValueBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1StatementList.html">StatementList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete AST nodes.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1StatementList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements...">Block</a> node represents a scoped list of statements. It may comprise of 0 or more statements, and specifically indicates that a new scope is activated, typically represented by curly braces. Note that a block does not alway have to be encapsulated by curly braces, but always represents a new scope.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a> is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExpressionList.html">ExpressionList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExpressionList.html" title="An ExpressionList is comprises of multiple expressions. These expressions are typically separated by ...">ExpressionList</a> is comprises of multiple expressions. These expressions are typically separated by ',' tokens to form argument lists for functions or single line declarations. This node is similar to a <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements...">Block</a> and <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1StatementList.html" title="Concrete AST nodes. ">StatementList</a>, except that it does not represent an additional scope and holds Expressions rather than Statements.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExpressionList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Loop.html">Loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops represent for, while and do-while loop constructs. These all consist of a condition - evaluated to determine if loop iteration should continue, and a body which is the logic to be repeated. For loops also have initial statements which are evaluated prior to loop execution (at loop scope) and commonly used to set up iterators, and iteration expressions which are evaluated between iterations after the body and before the condition. Both conditions and initial statements can be declarations or expressions, so are Statements, and iteration expressions can consist of multiple expressions so are stored as an <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExpressionList.html" title="An ExpressionList is comprises of multiple expressions. These expressions are typically separated by ...">ExpressionList</a>. The loop body is a <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements...">Block</a> defining its own scope (encapsulated by initial statement scope for for-loops).  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ConditionalStatement.html">ConditionalStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConditionalStatements represents all combinations of 'if', 'else' and 'else if' syntax and semantics. A single <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics...">ConditionalStatement</a> only ever represents up to two branches; an 'if' (then) and an optional 'else'. Multiple ConditionalStatements are nested within the second 'else' branch to support 'else if' logic. As well as both 'if' and 'else' branches, a <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics...">ConditionalStatement</a> also holds an <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a> related to its primary condition.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ConditionalStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1BinaryOperator.html">BinaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a> represents a single binary operation between a left hand side (LHS) and right hand side (RHS) expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v7__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only ever be a valid binary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1BinaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1AssignExpression.html">AssignExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AssignExpressions represents a similar object construction to a <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a>, however they specifically represent right hand size (RHS) to left hand side (LHS) traversal and assignment. AssignExpressions can be chained together and are thus derived as Expressions rather than Statements.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1AssignExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Crement.html">Crement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Crement.html" title="A Crement node represents a single increment &#39;++&#39; and decrement &#39;â€“&#39; operation. As well as it&#39;s creme...">Crement</a> node represents a single increment '++' and decrement '&ndash;' operation. As well as it's crement type, it also stores whether the semantics constructed a post or pre-crement i.e. ++a or a++.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Crement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1UnaryOperator.html">UnaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1UnaryOperator.html" title="A UnaryOperator represents a single unary operation on an expression. The operation type is stored as...">UnaryOperator</a> represents a single unary operation on an expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v7__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only every be a valid unary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1UnaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes represent the conversion of an underlying expression to a target type. <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes are typically constructed from functional notation and do not represent construction of the target type, rather a type-casted conversion.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1FunctionCall.html">FunctionCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FunctionCalls represent a single call to a function and any provided arguments. The argument list can be empty but must not be null. The function name is expected to exist in the AX function registry.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1FunctionCall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Keyword.html">Keyword</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keywords represent keyword statements defining changes in execution. These include those that define changes in loop execution such as break and continue, as well as return statements.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Keyword.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ArrayUnpack.html">ArrayUnpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ArrayUnpack.html" title="ArrayUnpack represent indexing operations into AX container types, primarily vectors and matrices ind...">ArrayUnpack</a> represent indexing operations into AX container types, primarily vectors and matrices indexed by the square brackets [] syntax. Multiple levels of indirection (multiple components) can be specified but current construction is limited to either a single or double component lookup. Providing two components infers a matrix indexing operation.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ArrayUnpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ArrayPack.html">ArrayPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ArrayPacks represent temporary container creations of arbitrary sizes, typically generated through the use of curly braces {}. It uses an <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExpressionList.html" title="An ExpressionList is comprises of multiple expressions. These expressions are typically separated by ...">ExpressionList</a> to store its array "arguments", allowing for complex expressions to generate array elements.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ArrayPack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes represent any access to a primitive value, typically associated with the '@' symbol syntax. Note that the AST does not store any additional information on the given attribute other than its name and type, which together form a unique <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> identifier known as the <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> 'token'. A 'primitive value' in this instance refers to a value on an OpenVDB Volume or OpenVDB Points tree.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> represent any access to external (custom) data, typically associated with the '$' symbol syntax. Note that the AST does not store any additional information on the given external other than its name and type, which together form a unique external identifier known as the <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> 'token'. This token is used by the compiler to map user provided values to these external values.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1ExternalVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1DeclareLocal.html">DeclareLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1DeclareLocal.html" title="DeclareLocal AST nodes symbolize a single type declaration of a local variable. Like Local AST nodes...">DeclareLocal</a> AST nodes symbolize a single type declaration of a local variable. Like <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> AST nodes, they derive from <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Variable.html" title="Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types...">Variable</a> and thus store the local variables name. They also however store its specified type. These have the important distinction of representing the initial creation and allocation of a variable, in comparison to a <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> node which only represents access.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1DeclareLocal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Local.html">Local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> AST nodes represent a single accesses to a local variable. The only store the name of the variable being accessed.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Value.html">Value&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical...">Value</a> (literal) AST node holds either literal text or absolute value information on all numerical, string and boolean constants. A single instance of a <a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical...">Value</a> is templated on the requested scalar, boolean or string type. If scalar or boolean value is constructed from a string (as typically is the case in the parser), the value is automatically converted to its numerical representation. If this fails, the original text is stored instead.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html">Value&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Values for strings.  <a href="structopenvdb_1_1v7__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v7__0"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__0.html">openvdb::v7_0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v7__0_1_1ax"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__0_1_1ax.html">openvdb::v7_0::ax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v7__0_1_1ax_1_1ast"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__0_1_1ax_1_1ast.html">openvdb::v7_0::ax::ast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a873b33c3140c3fcf3d1402a45f75d850"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Tree &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__0_1_1ax_1_1ast.html#a873b33c3140c3fcf3d1402a45f75d850">parse</a> (const char *code)</td></tr>
<tr class="memdesc:a873b33c3140c3fcf3d1402a45f75d850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an abstract syntax tree from a code snippet. If the code is not well formed, as defined b the AX grammar, a runtime exception will be thrown with the first lexer or parsing error.  <a href="namespaceopenvdb_1_1v7__0_1_1ax_1_1ast.html#a873b33c3140c3fcf3d1402a45f75d850">More...</a><br /></td></tr>
<tr class="separator:a873b33c3140c3fcf3d1402a45f75d850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b09029c125ac6d78398d06ec447f99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AST_8h.html#aa9b09029c125ac6d78398d06ec447f99">yyparse</a> (openvdb::ax::ast::Tree **tree)</td></tr>
<tr class="separator:aa9b09029c125ac6d78398d06ec447f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a46af646807e0797e72b6e8945e7ea88b"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AST_8h.html#a46af646807e0797e72b6e8945e7ea88b">yyin</a></td></tr>
<tr class="separator:a46af646807e0797e72b6e8945e7ea88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the definition for every abstract and concrete derived class which represent a particular abstract syntax tree (AST) node type. Also provides access to the parser for generating a fully constructed AST from a given string. </p>
<dl class="section author"><dt>Authors</dt><dd>Nick Avramoussis, Richard Jones</dd></dl>
<p>AST nodes represents a particular branch of a complete AST. Concrete nodes can be thought of as leaf node types which hold semantic information of a partial or complete statement or expression. A string of AX can be fully represented by building the correct AST structure. The AX grammar defined in axparser.y represents the valid mapping of a tokenized string to AST nodes.</p>
<p>AST node classes can either represent a "leaf-level" semantic component of a given AX AST, or an abstract base type. The latter are used by the parser and leaf-level AST nodes for storage of compatible child nodes, and provide grouping of various nodes which share common semantics. The main two types of abstract AST nodes are statements and expressions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa9b09029c125ac6d78398d06ec447f99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int yyparse </td>
          <td>(</td>
          <td class="paramtype">openvdb::ax::ast::Tree **&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a46af646807e0797e72b6e8945e7ea88b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* yyin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
